## No Account management
### Exposure
<p> We found an instance of No Account management due to the fact that we don't have a functioning login system in place. </p>

<p> By exploiting the lack of user accounts, anyone is able to add, retrieve, and delete objects from the database on the front and backend. </p>

### Repair
<p> UserModelController.cs on the web app side contained the vulnerability. We are able to fix with the following adjustment(s): </p>

<p> Add authentication to Startup.cs ConfigureServices method: </p>

```csharp
services.AddIdentity<ApplicationUser, IdentityRole>()
        .AddEntityFrameworkStores<ApplicationDbContext>()
        .AddDefaultTokenProviders();
```

<p> Add authentication to Startup.cs Configure method: </p>

```csharp
app.UseAuthentication();
```

<br>

## A4 Insecure Direct object references
### Exposure
<p> We found an instance of Insecure Direct object reference by not validating the user's authorization to modify or delete user data. </p>

<p> By exploiting insecure direct object references, we were able to use the admin only page as an anonymous user. </p>

### Repair
<p> HomeController.cs on the Web App contained the vulnerability. We are able to fix the issue by enabling Identity, then checking that the current user matches the id: </p>

<p> Current implementation: </p>

```csharp
public IActionResult Index(int? id)
{
    if (id != null)
    {
        UserModel userModel = _context.Users.FirstOrDefault(u => u.ID == id);
        if (userModel != null) ViewData["LoggedInUserName"] = userModel.UserName;
    }
    return View();
}
```

<p> Code to add: </p>

```csharp
if (user.Id != _userIdentity.GetUserId()){}
```

<br>

## A7 Missing function level access control
### Exposure
<p> We found an instance of missing function level access control by not utilizing any [Authorize] annotation on any API endpoints. </p>

<p> By exploiting missing function level access control, we were able to use postman to access any endpoint directly regardless of a user account. </p>

### Repair
<p> Blade/Material/Location Controllers contained the vulnerability. We are able to fix the vulnerabilities with the following adjustment(s): </p>

<p> Add roles to ConfigureServices() in Startup.cs </p>

```csharp
services.AddAuthorization(options =>
    {
        options.AddPolicy("RequireAdministratorRole", policy => policy.RequireRole("Administrator"));
    });
```

<p> Add authorization annotation to entire controller, but allow anonymous on get requests. </p>

```csharp
[Authorize(Roles = "Administrator")]
```
```csharp
[AllowAnonymous]
[HttpGet("{id:int}")]
public List<Blade> Blade(int id)
```

<br>

## A8 Cross site request forgery
### Exposure
<p> We found an instance of cross site request forgery by not using ValidateAntiForgeryToken annotation in Put/Post requests. </p>

<p> By exploiting cross site request forgery, malicious websites can use the authentication cookie if the user already had an authenticated session in the web browser. </p>

### Repair
<p> In ASP.NET Core MVC 2.0 the FormTagHelper injects anti-forgery tokens for HTML form elements. So we only need to worry about adding the annotation to our controllers or individual actions: </p>

```csharp
[ValidateAntiForgeryToken]
```

<p> Converting the Web App to Razor Pages can be a solution since they are automatically protected from XSRF/CSRF. </p>

## Resources
https://www.owasp.org/index.php/.NET_Security_Cheat_Sheet <br>
https://docs.microsoft.com/en-us/aspnet/core/security/authorization/simple <br>
https://docs.microsoft.com/en-us/aspnet/core/security/authorization/roles <br>
https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies <br>
https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery <br>
